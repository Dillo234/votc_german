#!/usr/bin/env python3
"""
Generate a hardcoded list of all modifiers for logging purposes.
This script scans vanilla game and all active mods to find all modifier definitions
and generates a scripted effect that checks each modifier.
"""

import os
import re
from pathlib import Path
from typing import Set, List, Dict

# Paths
GAME_DIR = Path(r"C:\Program Files (x86)\Steam\steamapps\common\Crusader Kings III\game")
MOD_DIR = Path(r"C:\Users\sared\Documents\Paradox Interactive\Crusader Kings III\mod\votc")
OUTPUT_FILE = MOD_DIR / "common/scripted_effects/log_modifiers_generated.txt"

# Collect all modifier names
modifier_names: Set[str] = set()

def load_blacklist() -> Set[str]:
    """Load the blacklist of invalid modifiers from invalid_modifiers.txt if it exists."""
    blacklist = set()
    blacklist_file = MOD_DIR / "invalid_modifiers.txt"
    
    if blacklist_file.exists():
        try:
            with open(blacklist_file, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line:  # Skip empty lines
                        blacklist.add(line)
            print(f"Loaded {len(blacklist)} modifiers from blacklist")
        except Exception as e:
            print(f"Error loading blacklist: {e}")
    else:
        print("No blacklist file found, will include all modifiers")
    
    return blacklist

def find_modifiers_in_directory(directory: Path) -> Set[str]:
    """Find all modifier definitions in a directory."""
    modifiers = set()
    
    if not directory.exists():
        return modifiers
    
    for file_path in directory.glob("*.txt"):
        try:
            with open(file_path, 'r', encoding='utf-8-sig') as f:
                content = f.read()
                # Find all modifier definitions like:
                # modifier_name = {
                # or modifier_name = {
                pattern = r'^([a-z0-9_]+)\s*=\s*\{'
                matches = re.findall(pattern, content, re.MULTILINE)
                modifiers.update(matches)
        except Exception as e:
            print(f"Error reading {file_path}: {e}")
    
    return modifiers

def find_all_modifiers() -> List[str]:
    """Find all modifiers in vanilla game and all mods."""
    all_modifiers = []
    
    # Scan vanilla game modifiers
    print("Scanning vanilla game modifiers...")
    vanilla_modifiers = find_modifiers_in_directory(GAME_DIR / "common/modifiers")
    all_modifiers.extend(sorted(vanilla_modifiers))
    print(f"Found {len(vanilla_modifiers)} vanilla modifiers")
    
    # Scan mods in playset
    # TODO: Need to determine which mods are active in the playset
    # For now, scan all mods in the mod directory
    print("Scanning mods...")
    if MOD_DIR.exists():
        for mod_folder in MOD_DIR.iterdir():
            if mod_folder.is_dir() and mod_folder.name != ".git":
                modifiers_dir = mod_folder / "common/modifiers"
                if modifiers_dir.exists():
                    mod_modifiers = find_modifiers_in_directory(modifiers_dir)
                    all_modifiers.extend(sorted(mod_modifiers))
                    print(f"Found {len(mod_modifiers)} modifiers in {mod_folder.name}")
    
    # Remove duplicates while preserving order
    seen = set()
    unique_modifiers = []
    for mod in all_modifiers:
        if mod not in seen:
            seen.add(mod)
            unique_modifiers.append(mod)
    
    print(f"\nTotal unique modifiers: {len(unique_modifiers)}")
    return unique_modifiers

def generate_scripted_effect(modifiers: List[str], blacklist: Set[str]) -> str:
    """Generate a scripted effect that checks each modifier."""
    output = []
    
    output.append("# Auto-generated by generate_modifiers_list.py")
    output.append("# DO NOT EDIT MANUALLY - regenerate with python generate_modifiers_list.py")
    output.append("")
    output.append("log_modifiers_generated = {")
    output.append("\t# Log all modifiers that the character has")
    output.append("\t# This is auto-generated from all modifiers in vanilla game and mods")
    output.append("\t# Format: VOTC:IN/;/modifier/;/char_id/;/modifier_id/;/localized_name/;/localized_desc")
    output.append("")
    
    # Generate check for each modifier that's not in the blacklist
    skipped_count = 0
    for i, modifier in enumerate(modifiers):
        if modifier in blacklist:
            skipped_count += 1
            continue
            
        output.append(f"\t# Check for {modifier}")
        output.append(f"\tif = {{")
        output.append(f"\t\tlimit = {{")
        output.append(f"\t\t\thas_character_modifier = {modifier}")
        output.append(f"\t\t}}")
        # Log: char_id, modifier_id, localized_name, localized_desc
        output.append(f"\t\tdebug_log = \"VOTC:IN/;/modifier/;/[THIS.Char.GetID]/;/{modifier}/;/[Localize(\'{modifier}\')]/;/[Localize(\'{modifier}_desc\')]\"")
        output.append(f"\t}}")
        output.append("")
    
    output.append("}")
    
    # Add summary comment at the end
    output.append("")
    output.append(f"# Generated checks for {len(modifiers) - skipped_count} modifiers")
    output.append(f"# Skipped {skipped_count} blacklisted modifiers")
    
    return "\n".join(output)

def main():
    print("="*60)
    print("Generating modifiers list for logging")
    print("="*60)
    
    # Load blacklist if it exists
    blacklist = load_blacklist()
    
    # Find all modifiers
    modifiers = find_all_modifiers()
    
    if not modifiers:
        print("No modifiers found!")
        return
    
    # Generate scripted effect
    print("\nGenerating scripted effect...")
    effect_content = generate_scripted_effect(modifiers, blacklist)
    
    # Write to file
    print(f"\nWriting to {OUTPUT_FILE}...")
    OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write(effect_content)
    
    included_count = len(modifiers) - len([m for m in modifiers if m in blacklist])
    print(f"Done! Generated checks for {included_count} modifiers (skipped {len(modifiers) - included_count} blacklisted)")
    print(f"Output: {OUTPUT_FILE}")
    
    # Also print summary
    print("\n" + "="*60)
    print("First 10 modifiers:")
    count = 0
    for mod in modifiers:
        if mod not in blacklist:
            print(f"  - {mod}")
            count += 1
            if count >= 10:
                break
    
    if len(modifiers) > 10:
        remaining = len([m for m in modifiers if m not in blacklist]) - count
        if remaining > 0:
            print(f"  ... and {remaining} more")
    
    if blacklist:
        print(f"\nBlacklisted modifiers (first 5):")
        for mod in list(blacklist)[:5]:
            print(f"  - {mod}")
        if len(blacklist) > 5:
            print(f"  ... and {len(blacklist) - 5} more")
    
    print("="*60)

if __name__ == "__main__":
    main()